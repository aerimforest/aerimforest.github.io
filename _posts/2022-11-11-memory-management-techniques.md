---
layout: post
title: 메모리 관리 기법
tags: [CS, 운영체제]
color: orange
author: aerimforest
excerpt_separator: <!--more-->
---

## 메모리 관리 배경
`다중 프로그래밍 시스템`에서는 여러 개의 프로세스가 실행되고, 각 프로세스는 독립적인 메모리를 할당받아야 한다.

따라서 어떤 프로세스에게 어떤 식으로, 얼마나 메모리를 할당할 것인지 주기억장치를 동적 분할하는 `메모리 관리` 작업이 필요하다.

<!--more-->

<br><br>

## 메모리 관리 기법
1.  교체 기법
-   Swapping  
  <br>
2.  할당 기법
-   연속 할당 기법  
        - 고정분할 방식  
        - 가변분할 방식  
  <br>
-   불연속 할당 기법  
        - 페이징(Paging)  
        - 세그멘테이션(Segmentation)  
  <br>
3.  배치 기법
-   최초 적합(First-Fit)
-   최적 적합(Best-Fit)
-   최악 적합(Worst-Fit)

<br><br>

## 교체 기법 - Swapping
`스와핑(Swapping)`은 현재 사용되지 않는 메모리 내용을 디스크의 `스왑 영역`으로 스왑하여 다른 응용 프로그램이나 프로세스에서 사용할 수 있도록 하는 `메모리 회수 방법`이다.

`스왑 영역`은 가상 메모리 관리를 위해 사용되는 디스크 영역이다. 프로세스가 수행 중인 동안에만 디스크에 일시적으로 저장하는 공간이기 때문에 휘발성이며 저장 기간이 짧다.

-   Swap in: 디스크에서 메모리로 올리는 작업
-   Swap out: 메모리에서 디스크로 내리는 작업

사용자가 B라는 프로그램을 실행하고 싶은데 이미 A라는 프로그램이 실행되고 있어서 메모리가 부족한 경우, 운영체제가 A 프로그램을 디스크로 내보낸다.(Swap out)

이제 여유 공간이 생겼으니 B를 메모리에 올린다.(Swap in) B가 충분히 실행되고 나면 B를 디스크로 내리고(Swap out), 대기하고 있던 A를 다시 메모리에 올린다.(Swap in)  
  
<br><br>

## 연속할당 기법
`연속할당 기법`은 프로세스를 메모리에 올릴 때 주소 공간을 여러 개로 분할하지 않고, 물리적 메모리의 한 곳에 `연속적으로` 적재하는 방식이다.  
연속할당 기법은 이 <u>물리적 메모리 공간을 어떻게 나누는지</u>에 따라 다시 `고정 분할 방식`과 `가변 분할 방식`으로 나뉜다.  
  
<br><br>

## 고정 분할 방식
`고정 분할 방식`은 물리적 메모리 공간을 고정된 크기로 분할하는 것이다. 

<br>

### 단점
-   융통성 부족  
    메모리에 동시에 올릴 수 있는 프로그램의 수가 한정되어 있고, 고정된 크기로 인해 수행 가능한 프로그램의 최대 크기 역시 제한되기 때문에 융통성이 떨어진다.  
    <br>
-   단편화(Fragmentation)  
      
<br><br>  

## 단편화
이미 고정된 크기로 정해져 있는 분할들이 꼭 맞는 크기의 프로세스들로 채워지는 것은 거의 불가능하다. 그렇기 때문에 분할 내에는 프로세스를 수용하고 남는 공간이 발생하게 된다. 이 공간은 해당 분할에 들어있는 프로세스가 나갈 때까지 사용되지 못하고 낭비된다.  
또한, 분할 크기를 너무 작게 잡을 경우 아예 프로세스가 적재되지 못하는 현상도 발생할 수 있다.

-   내부 단편화(Internal Fragmentation)  
    각 분할에 프로세스가 적재된 후 남은 공간을 말한다.   
    <br>
  ![그림1](https://user-images.githubusercontent.com/52696359/201410205-52ef25c7-1349-46a0-b34b-06cb503ef7e9.png)  
  <br>
-   외부 단편화(External Fragmentation)  
    분할 자체의 크기가 너무 작아서 프로세스를 수용할 수 없는 경우를 말한다.  
    <br>
    ![그림1](https://user-images.githubusercontent.com/52696359/201410509-44c49896-a029-4843-b81e-57e9c37a8be1.png)

<br><br>

## 가변 분할 방식
`가변 분할 방식`은 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식이다.
-   장점: 내부 단편화 발생 X  
    프로그램의 크기에 맞게 분할의 크기를 정하기 때문에 내부 단편화는 발생하지 않는다.  
    <br>
-   단점: 외부 단편화 발생 O  
    실행 중이던 프로그램이 종료될 경우 메모리에 빈 공간이 발생하고, 이 공간이 새로 시작될 프로그램의 크기보다 작은 경우 외부 단편화가 발생할 수 있다.  

<br>

가변 분할 방식에서는 프로세스를 메모리 공간의 <u>어디에</u> 적재할 것인지를 고려해야 한다. 이때 메모리 관리 기법 중 `배치 기법`을 적용한다.

-   최초 적합(First-Fit): 프로세스가 적재될 수 있는 가용 공간 중 <u>첫 번째 분할</u>에 할당하는 방식
-   최적 적합(Best-Fit): 가용 공간 중 <u>가장 크기가 비슷한 공간</u>을 선택하여 프로세스를 적재하는 방식
-   최악 적합(Worst-Fit): 프로세스의 가용 공간들 중에서 <u>가장 큰 공간</u>에 할당하는 방식

<br><br>
  
## 불연속 할당 기법

`불연속 할당 기법`은 하나의 프로세스가 물리적 메모리의 여러 위치에 분산되어 올라가는 메모리 할당 기법이다.

불연속 할당 기법은 <u>하나의 프로그램을 분할하는 기준</u>에 따라 아래의 두가지로 나뉜다.

-   페이징(Paging)
-   세그멘테이션(Segmentation)

<br><br>  

## 페이징(Paging)

모든 프로그램은 작은 조각들로 나눠지게 되는데, 조각들의 크기를 모두 같도록 할 때 한 조각을 `페이지(Page)`라고 부른다. 디스크 사이에서 한 번에 전송되는 전송 단위가 된다.

`페이징`이란, 프로세스의 주소 공간을 페이지 단위로 나누어 물리적 메모리의 서로 다른 위치에 저장하는 방식이다. 메모리 역시 페이지와 같은 크기의 `프레임` 단위로 나누어져 있다.

메모리를 페이지와 같은 크기로 미리 분할해두기 때문에 빈 프레임이 생기는 즉시 새로운 페이지가 적재될 수 있다. 따라서 외부 단편화는 발생하지 않는다.

하지만 프로그램의 크기가 항상 페이지 크기의 배수가 된다는 보장이 없기 때문에 `내부 단편화`가 발생할 수 있다.  
예를 들어, 프로세스 A가 3001B의 메모리를 필요로 하고 각 페이지의 크기가 1000B라면, A에 필요한 프레임은 총 4개이다.(1000 + 1000 + 1000 + 1) 따라서 1B가 적재되는 프레임은 999B의 낭비 공간이 생기는 것이다.

<br><br>

## 페이지 테이블

페이징 기법은 각 페이지를 메모리의 서로 다른 위치에 저장하기 때문에 특정 프로세스의 몇 번째 페이지가 메모리의 몇 번째 프레임에 적재되어있는지에 대한 정보가 필요하다.

이 정보를 담고 있는 것이 `페이지 테이블`이다.

![그림1](https://user-images.githubusercontent.com/52696359/201456351-30ba2534-6f64-46f1-a332-fc2a99d0fa8d.png)

<br><br>

## 세그먼테이션(Segmentation)

`세그먼테이션`은 프로세스의 주소 공간을 논리적 단위인 세그먼트로 나누어 물리적 메모리에 올리는 기법이다.

`세그먼트(Segment)`는 주소 공간을 기능 또는 의미 단위로 나눈 것을 말한다. 일반적으로 코드, 데이터, 스택 등의 기능 단위로 세그먼트를 정의한다.

세그먼트는 특정 크기로 나눈 것이 아니라 `논리적 단위`로 나눈 것이기 때문에 그 크기가 균일하지 않다. 따라서 페이징 기법보다 구현이 더욱 복잡하고, 서로 다른 크기의 세그먼트들을 메모리에 적재하는 관리 오버헤드가 발생하게 된다.

<br><br>

## 세그먼트 테이블
세그먼테이션 기법 역시 페이징 기법과 마찬가지로 주소 변환을 위해 세그먼트 테이블을 사용한다.

페이지 테이블과의 차이점은 <u>저장하고 있는 정보의 차이</u>이다.  
페이지 테이블은 모든 페이지의 크기가 동일하므로 각 페이지가 어디에 위치하고 있는지만 저장하면 된다.  
하지만 세그먼트의 크기는 균일하지 않기 때문에 `저장된 위치(base)`와 `세그먼트의 길이(limit)`를 함께 저장해줘야 한다.

<br><br>
  
## 함께 읽어보면 좋은 글
-   [http://terms.tta.or.kr/dictionary/dictionaryView.do?subject=%EA%B8%B0%EC%96%B5+%EC%9E%A5%EC%B9%98](http://terms.tta.or.kr/dictionary/dictionaryView.do?subject=%EA%B8%B0%EC%96%B5+%EC%9E%A5%EC%B9%98)  
      
<br><br>

## References
-   [https://github.com/JaeYeopHan/Interview\_Question\_for\_Beginner/tree/master/OS#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/OS#%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5)
-   [https://www.techopedia.com/definition/30467/memory-swapping](https://www.techopedia.com/definition/30467/memory-swapping)
-   📖 운영체제와 정보 기술의 원리
-   📖 OS? Oh Yes!